image: docker:latest
services:
  - docker:dind

variables:
  # Docker Hub Credentials (set as protected/masked CI/CD variables in GitLab)
  DOCKER_HUB_USERNAME: "$DOCKER_HUB_USERNAME"
  DOCKER_HUB_PASSWORD: "$DOCKER_HUB_PASSWORD"

  # Backend variables
  PYTHON_IMAGE_TAG: "3.9-slim-buster"
  DJANGO_PROJECT_ROOT: "." # Assuming Django project root is the GitLab CI root (where .gitlab-ci.yml is)
  DJANGO_IMAGE_NAME: "$DOCKER_HUB_USERNAME/delivery-backend"
  DJANGO_IMAGE_TAG: "${CI_COMMIT_REF_SLUG:-latest}" # Use branch/tag name or 'latest'

# Define the stages of the pipeline
stages:
  - install
  - test
  - build_docker
  - deploy # Optional: for deploying the entire application

# --------------------------------------------------------------------------
# Backend CI/CD Jobs
# --------------------------------------------------------------------------

install_backend_dependencies:
  stage: install
  image: python:$PYTHON_IMAGE_TAG
  cache:
    key: "$CI_COMMIT_REF_SLUG-backend"
    paths:
      - $DJANGO_PROJECT_ROOT/.venv/
    policy: pull-push # Cache the virtual environment
  script:
    - echo "Installing backend dependencies..."
    - cd $DJANGO_PROJECT_ROOT
    - python -m venv .venv
    - source .venv/bin/activate
    - pip install --upgrade pip
    - pip install -r requirements.txt
  rules:
    - changes:
        - $DJANGO_PROJECT_ROOT/**/* # Monitor all files in Django project root
        - .gitlab-ci.yml
    - when: always # Always run install on changes

test_backend_app:
  stage: test
  image: python:$PYTHON_IMAGE_TAG
  cache:
    key: "$CI_COMMIT_REF_SLUG-backend"
    paths:
      - $DJANGO_PROJECT_ROOT/.venv/
    policy: pull # Only pull cache
  needs: ["install_backend_dependencies"]
  script:
    - echo "Running backend tests..."
    - cd $DJANGO_PROJECT_ROOT
    - source .venv/bin/activate
    - python manage.py test # Assuming your tests are set up to run with this command
  rules:
    - changes:
        - $DJANGO_PROJECT_ROOT/**/*
        - .gitlab-ci.yml
    - when: always

build_backend_docker_image:
  stage: build_docker
  needs: ["test_backend_app"]
  script:
    - echo "Logging into Docker Hub for backend..."
    - docker login -u "$DOCKER_HUB_USERNAME" -p "$DOCKER_HUB_PASSWORD"
    - echo "Building backend Docker image..."
    # Assuming the Dockerfile for the backend is at the project root and named Dockerfile.backend
    - docker build -t "$DJANGO_IMAGE_NAME:$DJANGO_IMAGE_TAG" -f $DJANGO_PROJECT_ROOT/Dockerfile.backend $DJANGO_PROJECT_ROOT
    - echo "Pushing backend Docker image to Docker Hub..."
    - docker push "$DJANGO_IMAGE_NAME:$DJANGO_IMAGE_TAG"
    - echo "Backend Docker image pushed successfully!"
  rules:
    - changes:
        - $DJANGO_PROJECT_ROOT/**/*
        - $DJANGO_PROJECT_ROOT/Dockerfile.backend # Monitor changes in backend Dockerfile
        - .gitlab-ci.yml
    - when: always

# --------------------------------------------------------------------------
# Deployment Stage (Optional - Example)
# --------------------------------------------------------------------------

# deploy_to_production:
#   stage: deploy
#   image: alpine/helm:latest # Example: Using Helm for Kubernetes deployment
#   needs: ["build_backend_docker_image"]
#   script:
#     - echo "Deploying application to production..."
#     # Add your deployment specific commands here
#     # e.g., kubectl apply -f kubernetes/deployments.yaml
#     # e.g., helm upgrade --install my-app ./helm-chart
#   rules:
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # Only deploy from main branch
#       when: manual # Manual trigger for production deployment
